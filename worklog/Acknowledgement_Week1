Week 1-Part 1: Completed work:
1. Install and run arm-none-eabi-gcc and arm-none-eabi-gdb properly.
2. Install qemu for emulate the system
3. Compile and Run the project using Makefile for both VAB and VPB (switch option in Makefile)
4. Understand why is the bss section? Why it needs to be reset to 0: bss section is one of the portion of an object file, contains reserves space for uninitialized variables that are statically declared but not have been assigned a value yet. When the OS loads the executable, it just looks at the size of the .bss segment, allocates that much memory, and zero-initializes it. 
5. Understand why is the bss section aligned on a 16-byte boundary: The bss section needs to be zeroed on startup of the executable. The assembly writes 4 registers at a time, each of 32bits (4 bytes). 
  
Week 1-Part 2: Completed work:
1. Run debug the project step by step using arm-none-eabi-gdb. 
2. Understand the relationship between the linker script and memory map through kernel.ld file: a script contains commands that are used to configure how input files are to be compiled into an executable file, it can define an entry point, specify the sections (.text, .data, .rodata, COMMON, .bss,...), help control the memory layout. If we do not provide a linker script (.ld file), the toolchain provides one by default. Normally, this script is not suitable to use in bare metal devices.
Typically, .text, .rodata, .data(storage) are storaged in ROM, but .bss, COMMON, .data(usage) are storaged in RAM.   
3. Understand why _stack_top defined at the end of everything: The stack area is LIFO structure, typically located in the highest part of RAM.
